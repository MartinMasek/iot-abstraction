using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace Nuntius.Privacy
{
    /// <summary>
    /// This filter takes values of properties of a given message and replace them with hashed values represented
    /// as hexadecimal string. Uses UTF8 as encoding.
    /// </summary>
    public class HashFilter : EventSourceBase, IEventPropagator
    {
        private readonly string[] _keysToHash;
        private readonly HashAlgorithm _hashProvider;
        private static uint[] _lookupByteToHexTable;

        static HashFilter()
        {
            _lookupByteToHexTable = new uint[256];
            for (int i = 0; i < _lookupByteToHexTable.Length; i++)
            {
                var s = i.ToString("x2");
                _lookupByteToHexTable[i] = ((uint)s[0]) + ((uint)(s[1] << 16));
            }
        }

        /// <summary>
        /// Creates a new hash filter which does not check for exceptions in tasks returned by <see cref="Send"/> callbacks.
        /// </summary>
        /// <param name="hashType">Hash function to use.</param>
        /// <param name="keysToHash">Message keys whose values will be hashed and saved under the key.</param>
        public HashFilter(HashType hashType, params string[] keysToHash) : this(hashType, EventSourceCallbackMonitoringOptions.NotCheckTaskException, keysToHash)
        {
        }

        /// <summary>
        /// Creates a new hash filter.
        /// </summary>
        /// <param name="hashType">Hash function to use.</param>
        /// <param name="monitoringOption">How to behave when invoking <see cref="Send"/> callbacks.</param>
        /// <param name="keysToHash">Message keys whose values will be hashed and saved under the key.</param>
        public HashFilter(HashType hashType, EventSourceCallbackMonitoringOptions monitoringOption, params string[] keysToHash)
            : base(monitoringOption)
        {
            _keysToHash = keysToHash;
            switch (hashType)
            {
                case HashType.Sha256:
                    _hashProvider = new SHA256Managed();
                    break;
                default:
                    throw new ArgumentException($"Not implemented HashType option {hashType}");
            }
        }

        /// <summary>
        /// Returns a task which represents message processing by the event target.
        /// </summary>
        /// <param name="message">Message to process.</param>
        /// <returns>Task which represents message processing.</returns>
        public Task ProcessMessage(NuntiusMessage message)
        {
            // TODO move to task and create tests
            foreach (var key in _keysToHash)
            {
                var value = message[key];
                if (value == null)
                {
                    throw new KeyNotFoundException($"Key {key} was not present in the message.");
                }
                var hash = _hashProvider.ComputeHash(Encoding.UTF8.GetBytes(value));
                message[key] = GetHexaString(hash);
            }
            return Task.Factory.StartNew(() =>
            {
                SafelyInvokeSendEvent(message);
            });
        }


        /// <summary>
        /// Callback which is called when no more messages are generated by the event source.
        /// </summary>
        public void EndProcessing()
        {
            SafelyInvokeEndEvent();
        }

        private string GetHexaString(byte[] hash)
        {
            var result = new char[hash.Length * 2];
            for (int i = 0; i < hash.Length; i++)
            {
                var hexa = _lookupByteToHexTable[hash[i]];
                result[2 * i] = (char)hexa;
                result[2 * i + 1] = (char)(hexa >> 16);
            }
            return new string(result);
        }
    }

    public enum HashType
    {
        Sha256
    }
}
