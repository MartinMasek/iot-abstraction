using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace Nuntius.Privacy
{
    /// <summary>
    /// This filter takes values of properties of a given message and replace them with hashed values represented
    /// as hexadecimal string. Uses UTF8 as encoding.
    /// </summary>
    public class HashFilter : EventSourceBase, IEventPropagator
    {
        private readonly Func<string> _salt;
        private readonly string[] _keysToHash;
        private readonly HashAlgorithm _hashProvider;
        private static uint[] _lookupByteToHexTable;

        static HashFilter()
        {
            _lookupByteToHexTable = new uint[256];
            for (int i = 0; i < _lookupByteToHexTable.Length; i++)
            {
                var s = i.ToString("x2");
                _lookupByteToHexTable[i] = ((uint)s[0]) + ((uint)(s[1] << 16));
            }
        }

        /// <summary>
        /// Creates a new hash filter which does not check for exceptions in tasks returned by <see cref="Send"/> callbacks.
        /// </summary>
        /// <param name="hashType">Hash function to use.</param>
        /// <param name="keysToHash">Message keys whose values will be hashed and saved under the key.</param>
        public HashFilter(HashType hashType, params string[] keysToHash) : this(hashType, null, EventSourceCallbackMonitoringOptions.NotCheckTaskException, keysToHash)
        {
        }

        /// <summary>
        /// Creates a new hash filter which does not check for exceptions in tasks returned by <see cref="EventSourceBase.Send"/> callbacks.
        /// </summary>
        /// <param name="hashType">Hash function to use.</param>
        /// <param name="salt">Salt used in hashing. It will be appended to the hashed value before hashing and 
        /// hashed together.</param>
        /// <param name="keysToHash">Message keys whose values will be hashed and saved under the key.</param>
        public HashFilter(HashType hashType, Func<string> salt, params string[] keysToHash) : this(hashType, salt, EventSourceCallbackMonitoringOptions.NotCheckTaskException, keysToHash)
        {
        }

        /// <summary>
        /// Creates a new hash filter.
        /// </summary>
        /// <param name="hashType">Hash function to use.</param>
        /// <param name="salt">Salt used in hashing. It will be appended to the hashed value before hashing and 
        /// hashed together.</param>
        /// <param name="monitoringOption">How to behave when invoking <see cref="EventSourceBase.Send"/> callbacks.</param>
        /// <param name="keysToHash">Message keys whose values will be hashed and saved under the key.</param>
        public HashFilter(HashType hashType, Func<string> salt, EventSourceCallbackMonitoringOptions monitoringOption, params string[] keysToHash)
            : base(monitoringOption)
        {
            _salt = salt;
            _keysToHash = keysToHash;
            switch (hashType)
            {
                case HashType.Sha256:
                    _hashProvider = new SHA256Managed();
                    break;
                default:
                    throw new ArgumentException($"Not implemented HashType option {hashType}");
            }
        }

        /// <summary>
        /// Returns a task which represents message processing by the event target.
        /// </summary>
        /// <param name="message">Message to process.</param>
        /// <returns>Task which represents message processing.</returns>
        public Task ProcessMessage(NuntiusMessage message)
        {
            return Task.Factory.StartNew(() =>
            {
                foreach (var key in _keysToHash)
                {
                    var value = message[key];
                    if (value == null)
                    {
                        throw new KeyNotFoundException($"Key {key} was not present in the message.");
                    }
                    if (_salt != null) value += _salt();
                    var hash = _hashProvider.ComputeHash(Encoding.UTF8.GetBytes(value));
                    message[key] = GetHexaString(hash);
                }
                SafelyInvokeSendEvent(message);
            });
        }


        /// <summary>
        /// Callback which is called when no more messages are generated by the event source.
        /// </summary>
        public void EndProcessing()
        {
            SafelyInvokeEndEvent();
        }

        private string GetHexaString(byte[] hash)
        {
            var result = new char[hash.Length * 2];
            for (int i = 0; i < hash.Length; i++)
            {
                var hexa = _lookupByteToHexTable[hash[i]];
                result[2 * i] = (char)hexa;
                result[2 * i + 1] = (char)(hexa >> 16);
            }
            return new string(result);
        }
    }

    public enum HashType
    {
        Sha256
    }
}
